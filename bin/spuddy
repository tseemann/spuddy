#!/usr/bin/env perl
use 5.32.0;
use strict;
use warnings;
use Path::Tiny;
use Getopt::Std;
use File::Which;
use Data::Dumper;
use List::Util qw(min max sum);
use FindBin;

binmode(STDERR, ":utf8"); # for UTF-8 emoji

#......................................................................................
my $VERSION = "0.6.1";
my $EXE = path($0)->basename;
my $URL = 'https://github.com/tseemann/spuddy';
my $ICON = "\x{1F954}"; # potato

my %opt = (
#  'D' => 'kmers.7.1.50.db.95pc',
  'D' => 'kmers.K8.S1.M50.L50.db.99pc.zst',
  'c' => 11,
#  'L' => 'auto',
  'K' => '/dev/null',
  'O' => '/dev/null',
  'o' => '/dev/stdout',
  'j' => 'auto',
  'R' => 16,
  't' => '0.50',
  'p' => 'auto',
);
#......................................................................................
sub usage {
  my($errcode) = @_;
  $errcode ||= 0;
  my $ofh = $errcode ? \*STDERR : \*STDOUT;
  print $ofh 
    "NAME\n  $EXE $VERSION - bacterial species prediction\n",
    "USAGE\n  $EXE [opts] file.{fasta,fastq}[.gz]\n",
    "OPTIONS\n",
    "  -h       Print this help\n",
    "  -v       Print version and exit\n",
    "  -C       Show citation and exit\n",
    "  -q       No output while running, only errors\n",
    "  -d       Output debug information\n",
    "  -f FOFN  Input file of filenames\n",
    "SETTINGS\n",
    "  -D FILE  Database file [$opt{D}]\n",
    "  -c CODE  Genetic code [$opt{c}]\n",
#    "  -L LEN   Minimum protein length [$opt{L}]\n",
    "  -m       Metagenome mode\n",
    "OUTPUTS\n",
    "  -1       Just prin the prediction!\n",
    "  -t n.nn  Threshold for reporting [$opt{t}]\n",
    "  -o FILE  Species prediction result [$opt{o}]\n",
    "  -O FILE  Save raw result file [$opt{O}]\n",
    "  -K FILE  Save kmers to this file [$opt{K}]\n",
    "SPEED\n",
    "  -p PROP  Sample this proportion of input [$opt{p}]\n",
    "  -j CPUS  Threads to use [$opt{j}]\n",
    "  -R RAM   Keep RAM usage below [$opt{R}] GB\n",
    "HOMEPAGE\n  $URL\n",
    "END\n";
  exit($errcode);
}
#......................................................................................
sub msg { print STDERR "$ICON @_\n" unless $opt{'q'}; }
sub wrn { msg("WARNING:", @_); }
sub err { print STDERR "ERROR: @_\n"; exit(-1); }
#......................................................................................
getopts('vhqCdmM1c:f:D:L:K:j:R:O:o:p:t:', \%opt) or exit(-1);

$opt{'v'} and version();
$opt{'C'} and citation();
$opt{'h'} and usage(0);
$opt{'M'} and motd(42);

@ARGV or usage(1);

is_int($opt{'c'}, "Genetic code -c", 1, 33);
is_int($opt{'L'}, "Min ORF length -L", 30, 999);
is_int($opt{'R'}, "RAM -R", 1, 4096); # need ram()
is_file($opt{'D'}, "database -D");
is_float($opt{'p'}, "proportaion -p", 0, 1);
is_float($opt{'t'}, "threshold -t", 0, 1);
is_file($opt{'f'}, "FOFN -f") if $opt{'f'};

#......................................................................................
msg("This is $EXE $VERSION");
need_exe($_) for qw(
  parallel parsort awk sort join sed
  orfm zstd libdeflate-gzip seqkit tsvtk);

# set number of CPU cores if auto mode
my $cpus = num_cpus();
$opt{'j'} = $cpus if !$opt{j} or $opt{j} eq 'auto';
is_int($opt{j}, '-j CPUs', 1, $cpus);
msg("Will use $cpus threads and $opt{R} GB RAM");

# guess kmer size from DB name
$opt{'D'} =~ m/(\d+)/;
my $KMER = $1 or err("Can not determine database k-mer size");

# find the taxa table
my $species_of = load_taxa();

if (my $fofn = $opt{'f'}) {
  my @fofn = path($fofn)->lines({chomp=>1});
  msg("Read",0+@fofn,"filenames from $fofn");
  push @ARGV, @fofn;
}

#for my $infile (@ARGV) {
my $infile = shift @ARGV;
is_file($infile, "Input");

# Set paramets based on ASM, ILL< ONT
my $ss = seq_stats($infile);
$ss->{'type'} eq 'DNA' or err("Input is not DNA");
my $minlen = 600;
my $prop = $opt{'p'}; # eq 'auto' ? 1 : $opt{p};
my $orfm_opt = "-c $opt{c}";
if ($ss->{'avg_len'} <= 602) { # iSeq100+ soon?
  msg("Input looks like short reads");
  $prop = 0.005 if $prop eq 'auto';
  $minlen = int($ss->{'avg_len'} / 6);
  $minlen = $minlen - ($minlen % 3);
  $orfm_opt .= " -s";
}
else {
  $prop = 1 if $prop eq 'auto';
}
$orfm_opt .= " -m $minlen";
msg("Sampling ORFs > $minlen @ $prop");

my $PV = "pv -cpe";
my $metag = $opt{'m'} ? '' : '| LC_ALL=C uniq';
$opt{'m'} and msg("Enabled -m metagenome mode");
my $outfile = Path::Tiny->tempfile();
my $est_lines = int( $ss->{'sum_len'} );
my $pv_seq = $opt{'q'} ? ''  : "| $PV -N kmers -l -s $est_lines";
   
my $dbsize = uncompressed_size($opt{'D'});
msg(sprintf "Database is %d MB", $dbsize/1E6 );
my $pv_db = $opt{'q'} ? '' : "| $PV -N '$ICON Scanning' -s $dbsize";

my $to_fasta = $ss->{'type'} eq 'FASTQ'
  ? "| sed -n '1~4s/^\@.*\$/>x/p; 2~4p" : '';

my $cmd = "
   libdeflate-gzip -dcf \Q$infile\E
 $to_fasta
 | seqkit sample -p $prop -w 0 -j $cpus --quiet
 | orfm $orfm_opt
 | awk '{ for (i=1; i<=length(\$0)-$KMER+1; i++) print substr(\$0, i, $KMER) }'
 | grep -Ev '^>|[XUOW*]'
 | LC_ALL=C parsort \
            -S $opt{R}G 
            --parallel=$opt{j}
            --key=1.1,1.$KMER
            --stable
 $metag
 | tee \Q$opt{K}\E
 | LC_ALL=C join -t \$'\\t' -j 1 
            - <(zstd -dcf $opt{D} $pv_db)
 > $outfile
";
$cmd =~ s/\s+/ /xmsg;
msg("Running: $cmd") if $opt{'d'};
msg("Translating ORFs and making $KMER-mers...");
#msg("Scanning $infile against $opt{D}");
system('bash', '-c', $cmd)==0 or err($!);
$outfile->copy($opt{'O'});

my %score;
foreach (path($outfile)->lines({chomp=>1})) {
  # LYKYKVA 0.945946 105 Bacteria/Coprococcus/acet
  my(undef,$p,$taxid) = split m/\t/;
  $score{$taxid} += $p;
}
my $sum_score = sum(values %score);

my $out_fh = path($opt{'o'})->filehandle('>');
select $out_fh;

my @hit;
for my $taxid (sort { $score{$b} <=> $score{$a} } keys %score) {
  my $s_pc = $score{$taxid}*100/$sum_score,;
  last if $s_pc < $opt{'t'};
  my $name = $species_of->{$taxid} or err("Unknown taxon $taxid!");
  $name = join ' ', (split(m'/', $name, 3))[1,2] ;
  push @hit, [ $s_pc, $name, $score{$taxid} ];
}
push @hit, [ 0, "NO SPECIES", 0 ] unless @hit;

if ($opt{'1'}) {
  say "$infile\t$hit[0][1]\t$hit[0][2]";
}
else {
  printf "%.2f%%\t%s\n",, $_->[0], $_->[1] for @hit;  
}

msg( motd(0) );
msg("Thank you using $EXE !");
msg("Done.");
exit(0);

#......................................................................................
sub load_taxa {
  my $taxa_fn = $opt{'D'};
  $taxa_fn =~ s/\.db.*$/.taxa/;
  is_file($taxa_fn, "Taxa file");
  my $species_of = {
    map { split m/\t/ }
      path($taxa_fn)->lines({chomp=>1})
  };
  msg("Loaded", scalar(keys %$species_of), "taxa names");
  return $species_of;
}
#......................................................................................
sub seq_stats {
  my($fname, $max) = @_;
  $max //= "10M"; # peek at first 10 megabases
  msg("Assessing input file: $fname");
  my @line = qx"seqkit head -l $max \Q$fname\E | seqkit stats --quiet -T | tsvtk transpose -H -t";
  my $ss = { map { chomp; split m/\t/ } @line };
  say STDERR Dumper($ss) if $opt{d};
  return $ss;
}
#......................................................................................
sub uncompressed_size {
  my($zfile) = @_;
 my @line = qx"zstd -l -v \Q$zfile\E 2>/dev/null";
  # Decompressed Size: 7.12 GiB (7647074199 B)
  foreach (@line) {
    return $1 if 
      m/Decompressed S.*?\((\d+)\s+B/;
  }
  return 6*(-s $zfile); # fallback estimate
}
#......................................................................................
sub num_cpus {
  $_ = qx"nproc"; chomp; return $_;
}
#......................................................................................
sub is_file {
  my($fname, $name) = @_;
  -r $fname or err("$name '$fname' is not a valid file") ;
  return $fname;
} 
#......................................................................................
sub is_int {
  my($s, $name, $min, $max) = @_;
  return if !defined($s) or $s eq 'auto';
  $s =~ m/^[-+]?\d+$/ && $s >= $min && $s <= $max
    or err("$name must be an integer between $min and $max");
  return $s;
} 
#......................................................................................
sub is_float {
  my($s, $name, $min, $max) = @_;
  return if !defined($s) or $s eq 'auto';
  $s =~ m/^[-+]?\d+(\.\d+)?$/ && $s >= $min && $s <= $max
    or err("$name must be a number between $min and $max");
  return $s;
} 
#......................................................................................
sub need_exe {
  my($exe) = @_;
  my $p = which($exe) 
    or err("Please install '$exe'");
  msg("Using '$exe' => $p");
}
#......................................................................................
sub version { 
  say "$EXE $VERSION"; 
  exit(0); 
}
#......................................................................................
sub citation {
  say "Seemann T (2026), '$EXE' Github $URL";
  exit(0);
}
#......................................................................................
sub motd {
  my @motd = <DATA>;
  chomp @motd;
  if ($_[0]) { say "* $_" for @motd; exit(0); }
  return $motd[ int(rand(@motd)) ];
}
#......................................................................................

__DATA__
Maybe a potato can beat a fearsome octopus?
A 'spud' is a nickname for a potato
Potato is more versatile than baked goods
Potato, rice, or pasta - choose your starch weapon!
The German word for potato is 'Karoffel'
Unleash the potatoes!
Does gnocchi really count as pasta?
Check out the docs at https://github.com/tseemann/spuddy/
Not happy with $EXE ? Tell me at https://github.com/tseemann/spuddy/issues
Spuddy is your best buddy when it comes to bacterial ID
Sylph is also a good tool! https://github.com/bluenote-1577/sylph
Kraken is where it all began: https://github.com/DerrickWood/kraken2
Put another spud on the barbie!
My gaming PC is sad potato...
True Irish people eat potatoes three ways at every meal
Germanic potato salad is one of my favourite foods    
Did you know Spuddy runs mostly standard Unix tools?
If you owned an Intel 16" Macbook you know what a potato is.
In Australia we call (French) fries "chips"
Use -j to give Spuddy for CPUs to go even faster
Use -R to give Spuddy more RAM to go faster
What do you call 7 potatoes in a row? A potatomer.
In France, potato is pomme de terre
In Austria, potato is Erdapgel (earth apple)
In Italy, I say potato, they say patata.
