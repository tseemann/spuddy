#!/usr/bin/env perl
use 5.32.0;
use strict;
use warnings;
use Path::Tiny;
use Getopt::Std;
use File::Which;
use Data::Dumper;
use List::Util qw(min max sum);
use FindBin;

#......................................................................................
my $VERSION = "0.3.0";
my $EXE = path($0)->basename;
my $URL = 'https://github.com/tseemann/spuddy';

my %opt = (
#  'D' => 'kmers.7.1.50.db.95pc',
  'D' => 'kmers.K8.S1.M50.L50.db.99pc.zst',
  'c' => 11,
  'L' => 100,
  'K' => '/dev/null',
  'O' => '/dev/null',
  'o' => '/dev/stdout',
  'j' => 1,
  'R' => 8,
  'p' => '0.50',
  's' => '1.0',
);
#......................................................................................
sub usage {
  my($errcode) = @_;
  $errcode ||= 0;
  my $ofh = $errcode ? \*STDERR : \*STDOUT;
  print $ofh 
    "NAME\n  $EXE $VERSION - bacterial species prediction\n",
    "USAGE\n  $EXE [opts] file.{fasta,fastq}[.gz]\n",
    "OPTIONS\n",
    "  -h       Print this help\n",
    "  -v       Print version and exit\n",
    "  -C       Show citation and exit\n",
    "  -q       No output while running, only errors\n",
    "  -d       Output debug information\n",
    "SETTINGS\n",
    "  -D FILE  Database file [$opt{D}]\n",
    "  -c CODE  Genetic code [$opt{c}]\n",
    "  -L LEN   Minimum protein length [$opt{L}]\n",
    "  -s SAMP  Sample this proportion of input [$opt{s}]\n",
    "  -m       Metagenome mode\n",
    "OUTPUTS\n",
    "  -p n.nn  Threshold for reporting [$opt{p}]\n",
    "  -o FILE  Species prediction result [$opt{o}]\n",
    "  -O FILE  Save raw result file [$opt{O}]\n",
    "  -K FILE  Save kmers to this file [$opt{K}]\n",
    "SPEED\n",
    "  -j CPUS  Threads to use [$opt{j}]\n",
    "  -R RAM   Keep RAM usage below [$opt{R}] GB\n",
    "HOMEPAGE\n  $URL\n",
    "END\n";
  exit($errcode);
}
#......................................................................................
sub msg { print STDERR "@_\n" unless $opt{'q'}; }
sub wrn { msg("WARNING:", @_); }
sub err { print STDERR "ERROR: @_\n"; exit(-1); }
#......................................................................................
getopts('vhqCdmMc:D:L:K:j:R:O:o:p:s:', \%opt) or exit(-1);

$opt{'v'} and version();
$opt{'C'} and citation();
$opt{'h'} and usage(0);
$opt{'M'} and motd(42);

@ARGV or usage(1);

is_int($opt{'c'}, "-c", 1, 33);
is_int($opt{'L'}, "-L", 30, 999);
is_int($opt{'j'}, "-j", 1, 512); # need cpus()
is_int($opt{'R'}, "-R", 1, 4096); # need ram()
is_file($opt{'D'}, "-D");
is_float($opt{'p'}, "-p", 0, 1);
is_float($opt{'p'}, "-p", 0, 1);
is_float($opt{'s'}, "-p", 0, 1);

#......................................................................................
msg("This is $EXE $VERSION");
need_exe($_) for qw(
  orfm pyrodigal seqkit tsvtk zstd);

# guess kmer size from DB name
$opt{'D'} =~ m/(\d+)/;
my $KMER = $1 // 7;

# find the taxa table
my $taxa_fn = $opt{'D'};
$taxa_fn =~ s/\.db.*$/.taxa/;
is_file($taxa_fn, "Taxa file");
my %species_of = (
  map { split m/\t/ }
    path($taxa_fn)->lines({chomp=>1})
);
msg("Loaded", scalar(keys %species_of), "taxa names");

# just process the first file
my $infile = shift @ARGV;
is_file($infile, "Input");

# Set paramets based on ASM, ILL< ONT
my $ss = seq_stats($infile);
$ss->{'type'} eq 'DNA' or err("Input is not DNA");
my $minlen = max($KMER, min( 600, 
  int(0.5 * $ss->{'avg_len'} / 3) ) );
msg("Setting ORF LEN = $minlen");
#$opt{'s'} = 0.01 if $ss->{'avg_len'} < 500;

my $orfm_opt = "-c $opt{c} -m $minlen";
$orfm_opt .= " -s" if $minlen < 300;

my $PV = "pv -cpe";
my $metag = $opt{'m'} ? '' : '| LC_ALL=C uniq';
$opt{'m'} and msg("Enabled -m metagenome mode");
my $outfile = Path::Tiny->tempfile();
my $est_lines = int( $ss->{'sum_len'} );
my $pv_seq = $opt{'q'} ? ''  : "| $PV -N kmers -l -s $est_lines";
   
my $dbsize = uncompressed_size($opt{'D'});
msg("Database is $dbsize bytes");
my $pv_db = $opt{'q'} ? '' : "| $PV -N match -s $dbsize";

my $cmd = qq/
   seqkit sample -p $opt{s} \Q$infile\E
 | orfm $orfm_optd
 | seqkit sliding -w 0 -W $KMER -s 1
 | grep -Ev '^>|[XUOW*]'
 | LC_ALL=C sort --parallel=$opt{j} -S $opt{R}G
 $metag
 | tee \Q$opt{K}\E
 | LC_ALL=C join -t \$'\\t' -j 1 
            - <(zstd -dcf $opt{D} $pv_db)
 > $outfile
/;
$cmd =~ s/\s+/ /xmsg;
msg("Running: $cmd") if $opt{d};
msg("Translating ORFs and making $KMER-mers...");
#msg("Scanning $infile against $opt{D}");
system('bash', '-c', $cmd)==0 or err($!);
$outfile->copy($opt{'O'});

my %score;
my %match;
foreach (path($outfile)->lines({chomp=>1})) {
  # LYKYKVA 0.945946 105 Bacteria/Coprococcus/acet
  my(undef,$p,$taxid) = split m/\t/;
  $score{$taxid} += $p;
}
my $sum_score = sum(values %score);

my $out_fh = path($opt{'o'})->filehandle('>');
select $out_fh;

my $row=0;
for my $taxid (sort { $score{$b} <=> $score{$a} } keys %score) {
  next if $score{$taxid} <= 1;
  my $s_pc = $score{$taxid}*100/$sum_score,;
  last if $s_pc < $opt{'p'};
  my $name = $species_of{$taxid} or err("Unknown taxon $taxid!");
  $name = join ' ', (split(m'/', $name, 3))[1,2] ;
  # actual outpuit results
  printf "%.2f%\t%s\n", $s_pc, $name;
  $row++==0 and msg("PREDICTION: $name");  
}
msg( motd(0) );
msg("Done.");
exit(0);

#......................................................................................
sub seq_stats {
  my($fname, $max) = @_;
  $max //= "10M"; # peek at first 10 megabases
  msg("Assessing input file: $fname");
  my @line = qx"seqkit head -l $max \Q$fname\E | seqkit stats --quiet -T | tsvtk transpose -H -t";
  my $ss = { map { chomp; split m/\t/ } @line };
  say STDERR Dumper($ss) if $opt{d};
  return $ss;
}
#......................................................................................
sub uncompressed_size {
  my($zfile) = @_;
 my @line = qx"zstd -l -v \Q$zfile\E 2>/dev/null";
  # Decompressed Size: 7.12 GiB (7647074199 B)
  foreach (@line) {
    return $1 if 
      m/Decompressed S.*?\((\d+)\s+B/;
  }
  return 6*(-s $zfile); # fallback estimate
}
#......................................................................................
sub is_file {
  my($fname, $name) = @_;
  -r $fname or err("$name '$fname' is not a valid file") ;
} 
#......................................................................................
sub is_int {
  my($s, $name, $min, $max) = @_;
  $s =~ m/^[-+]?\d+$/ && $s >= $min && $s <= $max
    or err("$name must be an integer between $min and $max");
} 
#......................................................................................
sub is_float {
  my($s, $name, $min, $max) = @_;
  $s =~ m/^[-+]?\d+(\.\d+)?$/ && $s >= $min && $s <= $max
    or err("$name must be a number between $min and $max");
} 
#......................................................................................
sub need_exe {
  my($exe) = @_;
  my $p = which($exe) 
    or err("Please install '$exe'");
  msg("Using '$exe' => $p");
}
#......................................................................................
sub version { 
  say "$EXE $VERSION"; 
  exit(0); 
}
#......................................................................................
sub citation {
  say "Seemann T (2026), '$EXE' Github $URL";
  exit(0);
}
#......................................................................................
sub motd {
  my @motd = (
    "Maybe a potato can beat a fearsome octopus?",
    "A 'spud' is a nickname for a potato",
    "Potato is more versatile than baked goods",
    "Potato, rice, or pasta - choose your starch weapon!",
    "The German word for potato is 'Karoffel'",
    "Unleash the potatoes!",
    "Does gnocchi really count as pasta?",
    "Check out the docs at $URL",
    "Not happy with $EXE ? Tell me at $URL/issues",
    "Spuddy is your best buddy when it comes to bacterial ID",
    "Sylph is also a good tool! https://github.com/bluenote-1577/sylph",
    "Kraken is where it all began: https://github.com/DerrickWood/kraken2",
    "Put another spud on the barbie!",
    "I wouldn't put good money on $EXE\'s prediction",
    "My gaming PC is sad potato...",
    "True Irish people eat potatoes three ways at every meal",
    "Germanic potato salad is one of my favourite foods",    
  );
  if ($_[0]) { say "* $_" for @motd; exit(0); }
  return $motd[ int(rand(@motd)) ];
}
#......................................................................................

__DATA__
